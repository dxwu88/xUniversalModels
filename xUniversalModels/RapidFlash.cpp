#include "stdafx.h"
#include "RapidFlash.h"


RapidFlash::RapidFlash()
{
}


RapidFlash::~RapidFlash()
{
}

/***
Subroutine PTFlash(FEED, LIQ, VAP, TEMP, PRESS, VAPORFRAC,
	&ENTHALPY, PFLAG, RFLAG, IERROR)
	C *** CALCULATE VLE FOR Hydroprocessing USING SRK        ***
	C *** Based on method by Li and Johns, SPE 95732 * **
	C *** Society of Petroleum Engineers, 2005 * **
	C
	C  VARIABLES :
C	FEED(KL)    REAL * 8		MOLES OF MATERIAL TO BE FLASHED, LB - MOLE
C	LIQ(KL)		REAL * 8		MOLES OF LIQUID, LB - MOLE
C	VAP(KL)		REAL * 8		MOLES OF VAPOR, LB - MOLE
C	TEMP		REAL * 8		FLASH TEMPERATURE, DEGREES F
C	PRESS		REAL * 8		FLASH PRESSURE, PSIG
C	VAPORFRAC	REAL * 8		MOLAR FRACTION OF VAPOR TO FEED
C	ENTHALPY   	REAL * 8		ENTHALPY OF STREAM, BTU
C	PFLAG	    INT * 4		PRINT FLAG : 0 = NO OUTPUT FILE
C	RFLAG	    INT * 4		RESET FLAG : 0 = DON'T INITIALIZE
C     IERROR		INT * 4		ERROR FLAG : 0 = NO ERRORS
C
c
c  Expose subroutine
C**********************************************************************
!DEC$ATTRIBUTES DLLEXPORT, alias : 'PTFLASH'     ::PTFlash
!DEC$ATTRIBUTES STDCALL, REFERENCE::PTFlash
!DEC$ATTRIBUTES MIXED_STR_LEN_ARG::PTFlash
C**********************************************************************
C
USE DFPORT
USE COMPDATA
USE RAPIDDATA
IMPLICIT NONE
EXTERNAL ZSRK
INTEGER * 4 IERROR, PFLAG, I, RFLAG
REAL * 8 FEED(KL), LIQ(KL), VAP(KL), TEMP, PRESS, VAPORFRAC, ENTHALPY
REAL * 8 ZC, ZSRK
CHARACTER * 24 SYSTIME
C   CONVERT T AND P UNITS TO K AND ATM
TK = (TEMP + 459.67) / 1.8
PATM = (PRESS + 14.696) / 14.696
C   CALL FLASH ROUTINE
CALL SRKPTFlash(FEED, LIQ, VAP, TK, PATM, VAPORFRAC,
	&ENTHALPY, RFLAG, IERROR)
	C   PRINT FILE IF DESIRED
	IF(PFLAG.NE.0) THEN
	OPEN(unit = 66, FILE = 'RAPIDFLASH.TXT', STATUS = 'UNKNOWN')
	systime = CTIME(TIME())
	WRITE(66, *) ' *** SUBROUTINE RAPIDFLASH ***'
	write(66, *) ' Current date and time is ', systime
	WRITE(66, '(A,F7.1,A,F7.1,A)') ' *** FLASH RESULTS: AT T = ',
	&TEMP, ' F AND P = ', PRESS, ' PSIG ***'
	write(66, *) ' Stream Enthalpy (BTU) = ', Enthalpy
	write(66, *) ' Error Flag (K) = ', IERROR
	write(66, *) ' Vapor fraction = ', VAPORFRAC
	WRITE(66, '(3A)') ' C#        Feed        Liquid      ',
	&'X           Vapor',
	&'        Y           MW          K-VAP           Z'
	DO I = 1, KL
	ZC = ZSRK(I, TK, PATM)
	write(66, '(i3,6x,8g12.4)') i, feed(i), liq(i), X(I),
	&vap(i), Y(I), MW(I), VAPK(I), ZC
	ENDDO
	CLOSE(66)
	ENDIF
	RETURN
	END


	Subroutine SRKPTFlash(FEED, LIQ, VAP, TEMP, PRESS, VAPORFRAC,
		&ENTHALPY, RFLAG, IERROR)
	C *** CALCULATE VLE FOR Hydroprocessing USING SRK        ***
	C *** Based on method by Li and Johns, SPE 95732 * **
	C *** Society of Petroleum Engineers, 2005 * **
	C
	C  VARIABLES :
C	FEED(KL)	REAL * 8		MOLES OF MATERIAL TO BE FLASHED
C	LIQ(KL)		REAL * 8		MOLES OF LIQUID
C	VAP(KL)		REAL * 8		MOLES OF VAPOR
C	TEMP		REAL * 8		FLASH TEMPERATURE, DEGREES K
C	PRESS		REAL * 8		FLASH PRESSURE, ATM
C	VAPORFRAC	REAL * 8		MOLAR FRACTION OF VAPOR TO FEED
C	ENTHALPY   	REAL * 8		ENTHALPY OF STREAM, BTU
C	RFLAG	    INT * 4		RESET FLAG : 0 = DON'T INITIALIZE
C     IERROR		INT * 4		ERROR FLAG : 0 = NO ERRORS
C
C**********************************************************************
C
USE DFPORT
USE COMPDATA
USE RAPIDDATA
IMPLICIT NONE
EXTERNAL ZSRK, fcnrf, LSJACrf, FCNINITBETA
INTEGER * 4 IERROR, IER, RFLAG
REAL * 8    FEED(KL), LIQ(KL), VAP(KL), AF,
&DHLMX, DHVMX, ZSRK, TEMP, PRESS, VAPORFRAC, FTOL,
&TOTL, TOTV, TOTAL, ENTHALPY, FCNINITBETA
INTEGER ITMAX, NEQ, I
REAL * 8 ERRREL, XOUT(3), XGUESS(3), FNORM
LOGICAL STABILITYFLAG, check, USERSUPPLIED, VAPKUPDATEFLAG
LOGICAL TRYAGAIN

IF((SUM(X).LT.0.001D0).OR.(SUM(Y).LT.0.001D0)) THEN
C		SYSTEM MAY NOT BE INITIALIZED PROPERLY
RFLAG = 1
ENDIF
C	INITIALIZE VARIABLES
IF(RFLAG.NE.0) THEN
CALL ZEROVARIABLES
ENDIF
IER = 0
DHLMX = 0.0
DHVMX = 0.0
VAPKUPDATEFLAG = .FALSE.
TRYAGAIN = .FALSE.
FTOL = 1.0D - 010
TK = TEMP
PATM = PRESS
TOTAL = 1.0D0 / SUM(FEED)
TOTL = SUM(LIQ)
TOTV = SUM(VAP)
Z = FEED * TOTAL

IF(RFLAG.NE.0) THEN
C		INITIALIZE CALCULATIONS
IF((TOTL + TOTV).EQ.0.0) THEN
USERSUPPLIED = .FALSE.
VAPKUPDATEFLAG = .TRUE.
C			INITIALIZE VAPK ARRAY USING WILSON APPROXIMATION
CALL WILSONAPPROX(VAPK, PATM, TK, Z)
C			SOLVE FOR VAPFRAC USING RACHFORD - RICE METHOD
CALL RACHFORDRICE2(VAPK, Z, VAPFRAC, IERROR)
C			CALCULATE X AND Y
DO I = 1, KL
IF(FEED(I).GT.0.0D0) THEN
X(I) = Z(I) / (1.0D0 + VAPFRAC * (VAPK(I) - 1.0D0))
Y(I) = X(I)*VAPK(I)
ENDIF
ENDDO
X = X / SUM(X)
Y = Y / SUM(Y)
LIQ = X * (1.0D0 - VAPFRAC)*SUM(FEED)
VAP = Y * VAPFRAC*SUM(FEED)
ELSEIF((TOTL.EQ.0.0).OR.(TOTV.EQ.0.0)) THEN
C			INITIALIZE VAPK ARRAY USING WILSON APPROXIMATION
CALL WILSONAPPROX(VAPK, PATM, TK, Z)
C			SET VAPFRAC FROM INPUT
IF(TOTL.EQ.0.0) THEN
VAPFRAC = 0.99999
ELSE
VAPFRAC = 0.00001
ENDIF
C			CALCULATE X AND Y
DO I = 1, KL
IF(FEED(I).GT.0.0D0) THEN
X(I) = Z(I) / (1.0D0 + VAPFRAC * (VAPK(I) - 1.0D0))
Y(I) = X(I)*VAPK(I)
ENDIF
ENDDO
X = X / SUM(X)
Y = Y / SUM(Y)
LIQ = X * (1.0D0 - VAPFRAC)*SUM(FEED)
VAP = Y * VAPFRAC*SUM(FEED)
ELSE
C			INITIALIZE VAPK ARRAY USING LIQ AND VAP ARRAYS
USERSUPPLIED = .TRUE.
STABILITYFLAG = .FALSE.
VAPFRAC = TOTV * TOTAL
IF(TOTV.GT.0.0D0) TOTV = 1.0D0 / TOTV
TOTL = SUM(LIQ)
IF(TOTL.GT.0.0D0) TOTL = 1.0D0 / TOTL
DO I = 1, KL
IF(FEED(I).GT.0.0D0) THEN
Z(I) = FEED(I)*TOTAL
Y(I) = VAP(I)*TOTV
X(I) = LIQ(I)*TOTL
IF(X(I).LE.0.0) THEN
VAPK(I) = 1.0D20
ELSE
VAPK(I) = Y(I) / X(I)
ENDIF
ELSE
VAPK(I) = 0.0
ENDIF
ENDDO
VAPFRAC = SUM(VAP) / SUM(FEED)
ENDIF
ENDIF
C	CALCULATE DIMENSIONLESS PARAMETERS AND THETA ARRAYS
CALL CALCULATEPARAMETERS
C	DETERMINE IF TWO PHASES EXIST FROM A STABILITY ANALYSIS
C	SKIP THE STABILITY ANALYSIS IF USER SUPPLIED STARTING POINT
C	UPDATE KVAP FROM STABILITY ANALYSIS IF NEEDED
CALL StabilityCheck(STABILITYFLAG)
IF(STABILITYFLAG.EQ..TRUE.) THEN
C		ONLY 1 PHASE EXISTS
IF(THETAL(6).LT.0.5D0) THEN
VAPFRAC = 1.0D0
ELSE
VAPFRAC = 0.0D0
ENDIF
C		CONVERGE SOLUTION TO GET ENTHALPY DEPARTURE
ITMAX = 10
C		START WITH DIRECT SUBSTITUTION
CALL SOLVEDIRECTSUB(ITMAX, FNORM, FTOL, IERROR)
C		FOLLOW - UP WITH N - R
CALL SOLVENEWTONRAPHSON(FTOL, FNORM, CHECK, IERROR)
ELSE
C ************************************************************
C		FIRST - TRY INITIAL SOLUTION WITH DIRECT SUBSTITUTION METHOD
ITMAX = 50
CALL SOLVEDIRECTSUB(ITMAX, FNORM, FTOL, IERROR)
IF((FNORM.GT.FTOL).OR.(ISNAN(FNORM)).OR.(IERROR.NE.0))THEN
TRYAGAIN = .TRUE.
ENDIF
IF(TRYAGAIN.EQ..TRUE.) THEN
TRYAGAIN = .FALSE.
C ************************************************************
C			SECOND - SOLVE 3 EQUATIONS USING NEWTON - RAPHSON WITH LINE SEARCH METHOD
CALL SOLVENEWTONRAPHSON(FTOL, FNORM, CHECK, IERROR)
c			check if another attempt should be made at the solution with IMSL
IF((FNORM.GT.FTOL).OR.(ISNAN(FNORM)).OR.(IERROR.NE.0))THEN
TRYAGAIN = .TRUE.
ENDIF
ENDIF
IF(TRYAGAIN.EQ..TRUE.) THEN
TRYAGAIN = .FALSE.
C ************************************************************
C			THIRD - SOLVE 3 EQUATIONS USING MODIFIED POWELL'S HYBRID METHOD
call erset(0, 0, 0)
IERROR = 0
xout = 0.0d0
fnorm = 0.0d0
neq = 3
itmax = 200
XGUESS(1) = THETAL(1)
XGUESS(2) = THETAL(5)
XGUESS(3) = THETAL(6)
CALL DNEQNF(FCNrf, ERRREL, NEQ, ITMAX, XGUESS, XOUT, FNORM)
C			CALL DNEQNJ(FCNrf, LSJACrf, ERRREL, NEQ, ITMAX, XGUESS, XOUT,
	c     *						FNORM)
	IF((FNORM.GT.FTOL).OR.(ISNAN(FNORM))) THEN
	TRYAGAIN = .TRUE.
	endif
	endif
	C		CHECK IF THE SOLUTION MAKES SENSE(OUT OF 0 - 1 BOUNDS)
	IF((XOUT(3).LT. - 0.0001D0).OR.(XOUT(3).GT.1.0001D0))THEN
	TRYAGAIN = .TRUE.
	ENDIF
	IF(TRYAGAIN.EQ..TRUE.) THEN
	TRYAGAIN = .FALSE.
	C ************************************************************
	C			FORTH - SOLVE 3 EQUATIONS USING NEWTON - RAPHSON WITH LINE SEARCH METHOD
	C			TRY STARTING FROM A DIFFERENT INITIAL GUESS
	IF(USERSUPPLIED.EQ..TRUE.) THEN
	C				TRY A WILSON RESTART
	AF = PATM
	ELSE
	C				PERTERP PRESSURE TO GET A NEW STARTING POINT
	IF(XGUESS(3).GT.0.7) THEN
	AF = 0.7 * PATM
	ELSE
	AF = 1.2 * PATM
	ENDIF
	ENDIF
	CALL WILSONAPPROX(VAPK, AF, TK, Z)
	C			SOLVE FOR VAPFRAC USING RACHFORD - RICE METHOD
	CALL RACHFORDRICE2(VAPK, Z, VAPFRAC, IERROR)
	C			CALCULATE X AND Y
	DO I = 1, KL
	IF(Z(I).GT.0.0D0) THEN
	X(I) = Z(I) / (1.0D0 + VAPFRAC * (VAPK(I) - 1.0D0))
	Y(I) = X(I)*VAPK(I)
	ENDIF
	ENDDO
	X = X / SUM(X)
	Y = Y / SUM(Y)
	C			RECALCULATE THETA ARRAYS
	THETAL = 0.0
	THETAV = 0.0
	THETAT = 0.0
	DO I = 1, KL
	THETAL(1) = THETAL(1) + X(I)*AD(I)
	THETAL(5) = THETAL(5) + X(I)*BD(I)
	THETAV(1) = THETAV(1) + Y(I)*AD(I)
	THETAV(5) = THETAV(5) + Y(I)*BD(I)
	THETAT(1) = THETAT(1) + Z(I)*AD(I)
	THETAT(5) = THETAT(5) + Z(I)*BD(I)
	ENDDO
	IF(VAPFRAC.GT.0.999D0) VAPFRAC = 0.999D0
	IF(VAPFRAC.LT.0.001D0) VAPFRAC = 0.001D0
	THETAL(6) = 1.0 - VAPFRAC
	THETAV(6) = VAPFRAC
	THETAT(6) = 1.0
	ITMAX = 10
	C			START WITH DIRECT SUBSTITUTION
	CALL SOLVEDIRECTSUB(ITMAX, FNORM, FTOL, IERROR)
	C			FOLLOW - UP WITH N - R
	CALL SOLVENEWTONRAPHSON(FTOL, FNORM, CHECK, IERROR)
	endif
	IF(CHECK) FNORM = 1.0D0
	IF(ISNAN(SUM(X) + SUM(VAPK))) FNORM = 1.0D0
	IF((FNORM.GT.FTOL).OR.(ISNAN(FNORM)).OR.(IERROR.NE.0)) THEN
	C			CONVERGENCE FAILURE
	IERROR = 1
	LIQ = 0.0D0
	VAP = 0.0D0
	VAPORFRAC = 0.0D0
	Enthalpy = 0.0D0
	RETURN
	ENDIF
	C		SOLUTION FOR THIS SYSTEM
	VAPFRAC = 1.0D0 - THETAL(6)
	ENDIF
	C	CALCULATE LIQ AND VAP MOLAR FLOWS
	TOTAL = SUM(FEED)
	IF(VAPFRAC.LT.1.0D - 10) THEN
	VAPFRAC = 0.0
	TOTL = TOTAL
	TOTV = 0.0D0
	LIQ = FEED
	VAP = 0.0D0
	X = Z
	Y = 0.0D0
	ELSEIF(VAPFRAC.GT.0.999999999999D0) THEN
	VAPFRAC = 1.0
	TOTL = 0.0D0
	TOTV = TOTAL
	LIQ = 0.0D0
	VAP = FEED
	X = 0.0D0
	Y = Z
	ELSE
	TOTV = SUM(Y)
	TOTL = SUM(X)
	IF(TOTV.GT.0.0D0) THEN
	Y = Y / TOTV
	ELSE
	Y = 0.0D0
	ENDIF
	IF(TOTL.GT.0.0D0) THEN
	X = X / TOTL
	ELSE
	X = 0.0D0
	ENDIF
	TOTL = TOTAL * (1.0D0 - VAPFRAC)
	C		CALCULATE MOLAR FLOWS
	LIQ = 0.0
	VAP = 0.0
	DO I = 1, KL
	IF(FEED(I).GT.0.0) THEN
	LIQ(I) = TOTL * X(I)
	VAP(I) = FEED(I) - LIQ(I)
	ENDIF
	ENDDO
	ENDIF
	VAPORFRAC = VAPFRAC
	C	CALCULATE STREAM ENTHALPY
	C   Step 1: Calculate Ideal gas enthalpy(BTU / lb) API 7A1.1
	CALL IdealGasEnthalpy(FEED, TK, Enthalpy)
	C   Step 2 : Calculate enthalpy departure from ideal
	Call CalcEnthalpyDeparture(DHLMX, DHVMX)
	C     CONVERT TO BTU / LB - MOLE FROM KCAL / KG - MOLE
	DHLMX = DHLMX * 1.7988
	DHVMX = DHVMX * 1.7988
	C   Step 3 : Correct the ideal gas enthalpy
	TOTV = SUM(VAP)
	TOTL = SUM(LIQ)
	Enthalpy = Enthalpy - (DHLMX*TOTL + DHVMX * TOTV)

	RETURN
	END



	SUBROUTINE CALCULATEPARAMETERS
	C	CALCULATE THE DIMENSIONSLESS PARAMETERS FOR THIS PROBLEM
	USE RAPIDDATA
	USE COMPDATA
	IMPLICIT NONE
	INTEGER I
	REAL * 8 AMIX, BMIX, ZT, SQRTERM
	C	CALCULATE ANEW, B - SRK PARAMETERS FOR EACH COMPONENT
	C	THESE ARE BASED ON PRECALCULATED VALUES IN SRK2 ARRAY
	C	TEMPERATURE UNIT IS K, PRESSURE UNIT IS ATM
	C
	C     SRK2(I) = Tc(I) * SQRT(0.42748 / Pc(I)) IN K / SQRT(ATM)
	C     SRK2(KL + I) = 0.08664 * Tc(I) / Pc(I)  IN K / ATM
	C     SRK2(2 * KL + I) = 0.480 + 1.574*ACEN(I) - 0.176*ACEN(I)**2
	C
	C	THE PARAMETER ANEW IS SQRT(A)
	DO I = 1, KL
	if (Z(i).gt.0.0d0) then
		SQRTERM = DSQRT(TK*TCINV(I))
		IF(I.EQ.1) THEN
		C				HYDROGEN IS TREATED SPECIALLY
		ANEW(I) = SRK(I)*1.0963576D0*DEXP(-0.15114D0*TK*0.024D0)
		ELSE
		ANEW(I) = SRK2(I)*(1.0D0 + SRK2((KL * 2) + I)*
			*				(1.0 - SQRTERM))
		ENDIF
		B(I) = SRK2(KL + I)
		S(I) = SRK2(I)*SRK2((KL * 2) + I)*SQRTERM
		endif
		ENDDO
		C	INITIALIZE ARRAYS IN DIMENSIONLESS FORM
		H = 0.0
		G = 0.0
		PDAX = 0.0
		DO I = 1, KL
		AD(I) = ANEW(I)
		PDAX(I, 1) = ANEW(I)
		ENDDO
		AD = AD * SQRT(PATM) / TK
		BD = B * PATM / TK
		PDAX = PDAX * SQRT(PATM) / TK
		PDB = 0.0
		PDB(5) = 1.0
		C	CALCULATE INITIAL THETA ARRAYS
		THETAL = 0.0
		THETAV = 0.0
		THETAT = 0.0
		DO I = 1, KL
		THETAL(1) = THETAL(1) + X(I)*AD(I)
		THETAL(5) = THETAL(5) + X(I)*BD(I)
		THETAV(1) = THETAV(1) + Y(I)*AD(I)
		THETAV(5) = THETAV(5) + Y(I)*BD(I)
		THETAT(1) = THETAT(1) + Z(I)*AD(I)
		THETAT(5) = THETAT(5) + Z(I)*BD(I)
		ENDDO
		THETAL(6) = 1.0 - VAPFRAC
		THETAV(6) = VAPFRAC
		THETAT(6) = 1.0

		C	FEED FUGACITY
		AMIX = THETAT(1)*THETAT(1)
		BMIX = THETAT(5)
		CALL CALCZ(Z, AMIX, BMIX, U, W, ZT, .TRUE., .FALSE.)
		CALL CALCLOGFUGACITY(AD, BD, THETAT(1), BMIX, U, W, ZT, FUGFEED)
		RETURN
		END


		SUBROUTINE KVAPCALC
		C	CALCULATE THE VAPORIZATION K'S FOR RAPID FLASH
		C		1. SOLVE FOR Z - LIQUID, Z - VAPOR
		C		2. CALCULATE FUGACITY FOR LIQUID AND VAPOR
		C		3. CALUATE K(I) = FUGACITY - LIQUID(I) / FUGACITY - VAPOR(I)
		C
		USE RAPIDDATA
		USE COMPDATA
		IMPLICIT NONE
		INTEGER I
		REAL * 8 AMIX, BMIX, TOTAL
		C	CALCULATE Z AND FUGACITIES FOR LIQUID AND VAPOR PHASES
		C	LIQUID PHASE
		AMIX = THETAL(1)*THETAL(1)
		IF(THETAL(5).GT.0.0D0) THEN
		BMIX = THETAL(5)
		ELSE
		BMIX = 0.0D0
		DO I = 1, KL
		BMIX = BMIX + X(I)*BD(I)
		ENDDO
		ENDIF
		CALL CALCZ(X, AMIX, BMIX, U, W, ZL, .TRUE., .TRUE.)
		CALL CALCLOGFUGACITY(AD, BD, THETAL(1), BMIX, U, W, ZL, FUGACITYL)
		C	VAPOR PHASE
		AMIX = THETAV(1)*THETAV(1)
		IF(THETAV(5).GT.0.0D0) THEN
		BMIX = THETAV(5)
		ELSE
		BMIX = 0.0D0
		DO I = 1, KL
		BMIX = BMIX + Y(I)*BD(I)
		ENDDO
		ENDIF
		CALL CALCZ(Y, AMIX, BMIX, U, W, ZV, .FALSE., .TRUE.)
		CALL CALCLOGFUGACITY(AD, BD, THETAV(1), BMIX, U, W, ZV, FUGACITYV)
		C	CALCULATE VAPK ARRAY
		VAPK = 0.0D0
		IF((SUM(FUGACITYV).EQ.0.0).OR.(SUM(FUGACITYL).EQ.0.0))THEN
		C		PROBLEM WITH A FUGACITY CALCULATION
		C		CALCULATE VAPK ARRAY USING WILSON'S APPROXIMATION
		CALL WILSONAPPROX(VAPK, PATM, TK, Z)
		ELSE
		DO I = 1, KL
		IF(Z(I).GT.0.0) THEN
		TOTAL = FUGACITYL(I) - FUGACITYV(I)
		IF(TOTAL.GT.35.0D0)TOTAL = 35.0
		IF(TOTAL.LT. - 35.0D0)TOTAL = -35.0
		VAPK(I) = EXP(TOTAL)
		ENDIF
		ENDDO
		ENDIF
		RETURN
		END


		SUBROUTINE CALCZ(XYZ, AMIX, BMIX, U, W, ZCUBIC, ISLIQUID, BYGIBBS)
		C ************************************************************************
		C  THIS SUBROUTINE CALCULATES THE COMPRESSIBILITY FACTOR, Z,
		C   AT TEMP = T(K) AND PRESSURE = P(ATM)
		C
		C  VARIABLES :
C       XYZ(NC)  REAL * 8      COMPOSITION, USED FOR GR CALCULATION
C       AMIX     REAL * 8      DIMENSIONLESS PARAMETER FROM MIXING RULE
C       BMIX     REAL * 8      DIMENSIONLESS PARAMETER FROM MIXING RULE
C	  U        REAL * 8	   EOS PARAMETER, FOR SRK = 1
C	  W        REAL * 8	   EOS PARAMETER, FOR SRK = 0
C	  TK       REAL * 8	   MIXTURE TEMPERATURE, K
C	  PATM     REAL * 8	   MIXTURE PRESSURE, ATM
C       ZCUBIC   REAL * 8      THE SELECTED ROOT RETURN FROM SUBROUTINE
C       ZNL      REAL * 8      THE SELECTED ROOT WITHOUT LIMITATION
C       ISLIQUID LOGICAL = TRUE MEANS FIND THE LIQUID PHASE Z
C       BYGIBBS  LOGICAL = TRUE MEANS FIND Z WITH LOWEST GIBBS
C
C
C  METHOD :
C       SOLVE FOR Z WITH A CUBIC EQUATION OF STATE(SRK OR PR).
C			R*T        a
C		P = -- - -----------------, Z = PV / RT
C			V - b(V + U * b)*(V + W * b)
C
C		RESTATE IN DIMENSIONLESS FORM
C
C		Z*Z*Z + [(U + W - 1)*B - 1] * Z*Z + [(U*W - U - W)*B*B - (U + W)*B + A] * Z -
C(U*W*B*B*B + U * W*B*B + A * B) = 0
C
C		WHERE B = BMIX = P * b / (R*T), A = AMIX = P * a / (R*R*T*T)
C
C		SOLVE FOR REAL ROOTS OF EQUATION, PHYSICALLY MEANINGFUL
C		ROOTS ARE REAL AND POSITIVE.IF ISLIQUID = .TRUE.THEN
C		SELECT THE SMALLEST ROOT, OTHERWISE THE LARGEST ROOT.
C
C  NOTE : IN THIS SUB, AMIX = ALPHA * ALPHA
C
C ************************************************************************
USE RAPIDDATA, ONLY : NC
IMPLICIT NONE
REAL * 8  AMIX, BMIX, U, W, ZCUBIC, XYZ(NC)
REAL * 8  Z(3), PI, AX, BX, CX, Q, R, WW, A, B, BOLD, ZG
LOGICAL ISLIQUID, BYGIBBS

C   INITIALIZE
PI = 3.141593
Z = 0.0D0
ZCUBIC = 0.0
C   SOLVE FOR Z AS ROOT OF CUBIC EQUATION
C     Z**3 + AX * Z**2 + BX * Z + CX = 0
C	AX = BMIX * (U + W - 1.0D0) - 1.0D0
C     BX = (U*W - U - W)*BMIX*BMIX - (U + W)*BMIX + AMIX
C     CX = -(U*W*BMIX*BMIX*BMIX + U * W*BMIX*BMIX + AMIX * BMIX)
C
AX = BMIX * (U + W - 1.0D0) - 1.0D0
BX = (U*W - U - W)*BMIX*BMIX - (U + W)*BMIX + AMIX
CX = -(U*W*BMIX*BMIX*BMIX + U * W*BMIX*BMIX + AMIX * BMIX)

Q = (AX*AX - 3.0*BX) / 9.0
R = (2.0*AX*AX*AX - 9.0*AX*BX + 27.0*CX) / 54.0
BOLD = BMIX
CALL GUNDERSENROOT(AMIX, BMIX, ISLIQUID, ZG)
IF(ABS(BOLD - BMIX).GT.1.0D - 5) THEN
C		CALL AGAIN WITH NEW VALUE OF BMIX, THIS SHIFTS THE CURVE
CALL GUNDERSENROOT(AMIX, BMIX, ISLIQUID, ZG)
BMIX = BOLD
ENDIF
c	RETURN
IF((Q*Q*Q - R * R).GE.0.0) THEN
C       THE EQUATION HAS THREE REAL ROOTS
WW = DACOS(R / DSQRT(Q**3))
Z(1) = -2.0 * DSQRT(Q) * DCOS(WW / 3.0) - AX / 3.0
Z(2) = -2.0 * DSQRT(Q) * DCOS((WW + 2.0*PI) / 3.0) - AX / 3.0
Z(3) = -2.0 * DSQRT(Q) * DCOS((WW - 2.0*PI) / 3.0) - AX / 3.0
C		SELECT THE ROOT THAT IS POSITIVE AND HAS THE LOWEST GR
CALL SELECTROOT(XYZ, Z, AMIX, BMIX, BYGIBBS, ISLIQUID, ZCUBIC)
ELSE
C       THE EQUATION HAS ONE REAL ROOT
A = -DSIGN(1.0D0, R)*(DSQRT(R*R - Q * Q*Q) +
	&DABS(R))**(1.0D0 / 3.0D0)
	IF(A.NE.0.0) THEN
	B = Q / A
	ELSE
	B = 0.0
	ENDIF
	ZCUBIC = (A + B) - AX / 3.0
	ENDIF
	IF(ABS(ZG - ZCUBIC).GT.0.0001D0) THEN
	if (isliquid.eq..true.) then
		zcubic = min(zg, zcubic)
	else
		zcubic = max(zg, zcubic)
		endif
		ENDIF

		RETURN
		END


		SUBROUTINE GUNDERSENROOT(AMIX, BMIX, ISLIQUID, Z)
		C	SELECT SRK ROOT AND CALCULATE Z BASED ON METHOD OF GUNDERSEN
		C	COMPUTERS AND CHEM ENG, VOL 6, NO 3, P245 - 255, 1982
		IMPLICIT NONE
		REAL * 8  Q, R, Z, F, ONETHIRD, STARTZ, AMIX, BMIX, BNEW
		REAL * 8	ZOLD, ZOLD2, ARG, F1, F2, Z1, Z2, BOLD
		LOGICAL ISLIQUID, FINISHED
		INTEGER I
		C	DEFINE F, SEE EQUATION 10
		F(ARG) = (ARG*ARG*ARG) - (ARG*ARG) + (ARG*Q) - R
		ONETHIRD = 1.0D0 / 3.0D0
		BNEW = 0.0D0
		FINISHED = .FALSE.
		C  Get the coefficients 'Q' and 'R' and see if only one root with no
		C  maximum or minimum.
		Q = AMIX - BMIX - BMIX * *2.0D0
		R = AMIX * BMIX
		IF(Q.GT.ONETHIRD)THEN
		IF(F(ONETHIRD).GT.0.0D0)THEN
		STARTZ = 0.0D0
		ELSE
		STARTZ = 1.0D0
		ENDIF
		ELSE
		C		For the vapor phase, 'R' greater than 1 / 27 means one root, greater
		C		than 1 / 3.  Otherwise find where the minimum and use it if no vapor -
		C		like root.
		IF((R.GT.1.0D0 / 27.0D0).AND.(ISLIQUID.EQ..FALSE.))THEN
		STARTZ = 1.0D0
		ELSE
		BOLD = BMIX
		IF(ISLIQUID.EQ..TRUE.) THEN
		Z1 = ONETHIRD + ONETHIRD * DSQRT(1.0D0 - 3.0D0*Q)
		F1 = F(Z1)
		IF(F(Z1).GT.0.0D0) THEN
		STARTZ = 0.0D0
		ELSE
		C					Z = Z1, BNEW = B * (1 + F1 / R)
		Z = Z1
		BMIX = BMIX * (1.0D0 + F1 / R)
		C					IF CHANGE MAKES BMIX NEGATIVE THEN DON'T BOTHER
		IF(BMIX.LE.0.0D0) BMIX = BOLD
		FINISHED = .TRUE.
		END IF
		ELSE
		Z2 = ONETHIRD - ONETHIRD * DSQRT(1.0D0 - 3.0D0*Q)
		F2 = F(Z2)
		IF(F(Z2).LT.0.0D0) THEN
		STARTZ = 1.0D0
		ELSE
		C					Z = Z2, BNEW = B * (1 + F2 / R)
		Z = Z2
		BMIX = BMIX * (1.0D0 + F2 / R)
		C					IF CHANGE MAKES BMIX NEGATIVE THEN DON'T BOTHER
		IF(BMIX.LE.0.0D0) BMIX = BOLD
		FINISHED = .TRUE.
		ENDIF
		ENDIF
		ENDIF
		ENDIF
		IF(FINISHED.EQ..FALSE.)THEN
		C  Solve for Z using Newton's method.  Iterate until no change in Z.
		I = 0
		FINISHED = .FALSE.
		Z = STARTZ
		ZOLD = Z
		ZOLD2 = 0.0D0
		DO WHILE(FINISHED.EQ..FALSE.)
		Z = Z - F(Z) / (Q + (3.0D0*Z - 2.0D0)*Z)
		IF((DABS(Z - ZOLD).GT. 1.0D - 10).OR.
			*				(DABS(Z - ZOLD2).GT. 1.0D - 10))THEN
		ZOLD = Z
		ZOLD2 = ZOLD
		I = I + 1
		ELSE
		FINISHED = .TRUE.
		ENDIF
		IF(I.GT.200)THEN
		FINISHED = .TRUE.
		ENDIF
		END DO
		ENDIF
		RETURN
		END




		SUBROUTINE SELECTROOT(XYZ, ZC, AMIX, BMIX, BYGIBBS, ISLIQUID, ZCUBIC)
		C	SELECT THE ROOT > 0 WITH MINIMUM GIBBS ENERGY OR BY SMALL / LARGE
		C	BASED ON ISLIQUID FLAG.
		USE RAPIDDATA
		REAL * 8  AMIX, BMIX, ZCUBIC, XYZ(NC), ZC(3), GR(3), FUG(NC)
		LOGICAL ISLIQUID, BYGIBBS
		INTEGER I, N, J, IMIN

		C	COUNT THE NUMBER OF ROOTS > 0
		N = 0
		DO I = 1, 3
		IF(ZC(I).GT.0.0D0) THEN
		N = N + 1
		ENDIF
		ENDDO
		IF(N.EQ.0) THEN
		C		NO POSITIVE ROOTS
		ZCUBIC = 0.0
		RETURN
		ENDIF
		C	FIND THE FIRST ZC ELEMENT THAT IS > 0
		IMIN = 0
		DO I = 1, 3
		IF(ZC(I).GT.0.0D0) THEN
		IMIN = I
		EXIT
		ENDIF
		ENDDO
		C	CHECK IF ONLY ONE POSITIVE ROOT AND RETURN IT
		IF(N.EQ.1) THEN
		ZCUBIC = ZC(IMIN)
		RETURN
		ENDIF
		IF(BYGIBBS.EQ..TRUE.) THEN
		C		SELECT THE ROOT THAT IS POSITIVE AND HAS THE LOWEST GIBBS
		AMIX = DSQRT(AMIX)
		GR = 0.0D0
		DO N = IMIN, 3
		IF(ZC(N).GT.0.0D0) THEN
		C				CALCULATE GR FOR THIS ROOT
		CALL CALCLOGFUGACITY(AD, BD, AMIX, BMIX, U, W, ZC(N), FUG)
		DO I = 1, NC
		IF(XYZ(I).GT.0.0D0) THEN
		GR(N) = GR(N) + XYZ(I)*FUG(I)
		ENDIF
		ENDDO
		ENDIF
		ENDDO
		C		SELECT THE ROOT WITH THE LOWEST GR
		J = IMIN
		DO I = IMIN, 3
		IF((ZC(I).GT.0.0D0).AND.(GR(I).LT.GR(J))) THEN
		J = I
		ENDIF
		ENDDO
		ZCUBIC = ZC(J)
		ELSE
		IF(ISLIQUID.EQ..FALSE.) THEN
		C			SELECT THE LARGEST VALUE
		ZCUBIC = MAXVAL(ZC)
		ELSE
		C			SELECT THE SMALLEST VALUE THAT IS > 0.
		ZCUBIC = ZC(IMIN)
		DO I = IMIN, 3
		IF((ZC(I).LT.ZCUBIC).AND.(ZC(I).GT.0.0D0)) THEN
		ZCUBIC = ZC(I)
		ENDIF
		ENDDO
		ENDIF
		ENDIF
		RETURN
		END



		SUBROUTINE CALCLOGFUGACITY(AD, BD, AMIX, BMIX, U, W, Z, FUG)
		C ************************************************************************
		C  THIS SUBROUTINE CALCULATES THE LOG OF FUGACITIES FOR ALL COMPONENTS
		C   AT TEMP = T(K) AND PRESSURE = P(ATM)
		C
		C  VARIABLES :
C       AD(NC)   REAL * 8  ANEW(I)*SQRT(P) / (R*T), DIMENSIONLESS
C       BD(NC)   REAL * 8  B(I)*P / (R*T), DIMENSIONLESS
C       AMIX     REAL * 8  ANEW - MIX * SQRT(P) / (R*T), DIMENSIONLESS
C       BMIX     REAL * 8  B - MIX * P / (R*T), DIMENSIONLESS
C	  U        REAL * 8  EOS PARAMETER, FOR SRK = 1
C	  W        REAL * 8  EOS PARAMETER, FOR SRK = 0
C	  Z        REAL * 8  COMPRESSIBILITY FACTOR
C	  FUG(NC)  REAL * 8  LOG(FUGACITY COEFFICIENT) ARRAY
C
C  METHOD :
C     SOLVE FOR LOG(FUGACITY(I)) = Q0 + Q1 * AD(I) + Q2 * BD(I)
C
C	WHERE : Q0 = -DLOG(Z - BMIX)
C			Q1 = -2.0D0*AMIX*DLOG((Z + U * BMIX) / (Z + W * BMIX)) /
C((U - W)*BMIX)
C			Q2 = (Z - 1.0D0) / BMIX - Q1 * AMIX / (2.0D0*BMIX)
C
C  NOTE : IN THIS SUB, AMIX = ALPHA
C
C ************************************************************************
USE RAPIDDATA, ONLY : NC
IMPLICIT NONE
INTEGER I

REAL * 8  AD(NC), BD(NC), AMIX, BMIX, U, W, Z, FUG(NC)
REAL * 8  Q0, Q1, Q2
C   INITIALIZE Q0, Q1, Q2
Q0 = -DLOG(DABS(Z - BMIX))
Q1 = -2.0D0*AMIX*DLOG(ABS((Z + U * BMIX) / (Z + W * BMIX))) / ((U - W)*BMIX)
Q2 = (Z - 1.0D0) / BMIX - Q1 * AMIX / (2.0D0*BMIX)
C   SOLVE FOR FUGACITY
FUG = 0.0
DO I = 1, NC
IF(AD(I).GT.0.0D0) THEN
FUG(I) = Q0 + Q1 * AD(I) + Q2 * BD(I)
ENDIF
ENDDO

RETURN
END




SUBROUTINE CalcEnthalpyDeparture(DHLMX, DHVMX)
C	CALCULATE THE ENTHALPY DEPARTURE IN KCAL / KG - MOLE
C	TK         REAL * 8	STREAM TEMPERATURE, K
C	DHLMX      REAL * 8	Liquid enthalpy departure from Ideal Gas
C	DHVMX      REAL * 8	Vapor enthalpy departure from Ideal Gas
C
USE RAPIDDATA
IMPLICIT NONE
INTEGER I
REAL * 8 DHLMX, DHVMX, AA, BB, S1, S2, RGAS

RGAS = 1.987
C	CALCULATE LIQUID
C	S1 HAS UNITS OF K / SQRT(ATM), S2 HAS UNITS OF K / SQRT(ATM)
DHLMX = 0.0D0
IF(SUM(X).GT.0.0D0) THEN
S1 = 0.0D0
S2 = 0.0D0
DO I = 1, NC
S1 = S1 + X(I)*ANEW(I)
S2 = S2 + X(I)*S(I)
ENDDO
BB = THETAL(5)
AA = THETAL(1)*THETAL(1)
C		CHECK ZL AND CALCULATE IF NEEDED
IF(ZL.LE.0.0D0) THEN
CALL CALCZ(X, AA, BB, U, W, ZL, .TRUE., .FALSE.)
ENDIF
IF(ZL.GT.0.0D0) THEN
DHLMX = -(ZL - 1.0D0 - (1.0D0 + (S2 / S1))*AA*
	*					DLOG(1.0D0 + (BB / ZL)) / BB)*RGAS*TK
	ENDIF
	ENDIF
	C	CALCULATE VAPOR
	C	S1 HAS UNITS OF K / SQRT(ATM), S2 HAS UNITS OF K / SQRT(ATM)
	DHVMX = 0.0D0
	IF(SUM(Y).GT.0.0D0) THEN
	S1 = 0.0D0
	S2 = 0.0D0
	DO I = 1, NC
	S1 = S1 + Y(I)*ANEW(I)
	S2 = S2 + Y(I)*S(I)
	ENDDO
	BB = THETAV(5)
	AA = THETAV(1)*THETAV(1)
	C		CHECK ZV AND CALCULATE IF NEEDED
	IF(ZV.LE.0.0D0) THEN
	CALL CALCZ(X, AA, BB, U, W, ZV, .FALSE., .FALSE.)
	ENDIF
	IF(ZV.GT.0.0D0) THEN
	DHVMX = -(ZV - 1.0D0 - (1.0D0 + (S2 / S1))*AA*
		*					DLOG(1.0D0 + (BB / ZV)) / BB)*RGAS*TK
	ENDIF
	ENDIF

	RETURN
	END


	SUBROUTINE RACHFORDRICE2(VAPKS, ZS, BETA1, IERROR)
	C	SOLVE FOR VAPOR FRACTION WITH RACHFORD RICE METHOD
	USE RAPIDDATA
	IMPLICIT NONE
	REAL * 8  VAPKS(NC), ZS(NC), BETA1, T1, T2, F, FP, TOL, B1, B1OLD, P1, P2
	INTEGER ITMAX, IERROR, I, N
	IERROR = 0
	C	CHECK IF THERE IS A ROOT ON THE INTERVAL 0 TO 1
	T1 = 0.0D0
	T2 = 0.0D0
	F = 0.0D0
	FP = 0.0D0
	C	DEFINE THE VARIABLE, B1 - THIS IS(1 - BETA1) AND IS USED BY
	C	THE SUGGESTION OF MOLLERUP AND MICHELSEN(1996 - Pokki thesis)
	C	TO REDUCE PROBLEMS FROM ROUNDOFF ERRORS.
	B1 = 0.5
	DO I = 1, NC
	IF(ZS(I).GT.0.0D0) THEN
	T1 = T1 + VAPKS(I)*ZS(I)
	T2 = T2 + ZS(I) / VAPKS(I)
	P1 = VAPKS(I) - 1.0D0
	P2 = B1 + (1.0D0 - B1)*VAPKS(I)
	F = F + ZS(I)*P1 / P2
	FP = FP + ZS(I)*P1*P1 / (P2*P2)
	ENDIF
	ENDDO
	IF((T1.GE.1.0D0).AND.(T2.GE.1.0D0)) THEN
	C		SOLVE WITH NEWTONS METHOD
	TOL = 1.0D - 5
	ITMAX = 1000
	DO N = 1, ITMAX
	IF(DABS(F).LT.TOL) THEN
	BETA1 = 1.0D0 - B1
	RETURN
	ENDIF
	c			calculate new B1
	B1OLD = B1
	B1 = B1OLD - (F / FP)
	C			VALID RANGE IS 0 TO 1, DON'T LET IT OVERSHOOT
	IF(B1.LT.0.0D0) THEN
	B1 = B1OLD / 2.0D0
	ELSEIF(B1.GT.1.0D0) THEN
	B1 = B1OLD + 0.5*(1.0D0 - B1OLD)
	ENDIF
	FP = 0.0D0
	F = 0.0D0
	DO I = 1, NC
	IF(ZS(I).GT.0.0D0) THEN
	P1 = VAPKS(I) - 1.0D0
	P2 = B1 + (1.0D0 - B1)*VAPKS(I)
	F = F + ZS(I)*P1 / P2
	FP = FP + ZS(I)*P1*P1 / (P2*P2)
	ENDIF
	ENDDO
	ENDDO
	IERROR = 1
	BETA1 = 1.0D0 - B1
	ELSEIF(T1.LT.1.0D0) THEN
	c		subcooled liquid
	BETA1 = 0.0D0
	ELSE
	c		superheated vapor
	BETA1 = 1.0D0
	ENDIF
	RETURN
	END






	SUBROUTINE StabilityCheck(STABILITYFLAG)
	C	ROUTINE TO DETERMINE IF MIXTURE IS STABLE(2 EQ PHASES
		C	DO NOT EXIST) AND SET STABILITYFLAG = TRUE IF THAT IS
	C	THE CASE.USES METHOD OF M.L.MICHELSEN, IND.ENG.CHEM.PROCESS
	C	DES.DEV., VOL 25, NO. 1, P184 - 188 (1986)
	C
	C	VARIABLES
	C	STABILITYFLAG	LOGICAL		FLAG = TRUE IF PHASE IS STABLE
	C
	USE RAPIDDATA
	IMPLICIT NONE
	EXTERNAL FCNSTAB, JACStab
	LOGICAL STABILITYFLAG, CHECK
	REAL * 8  G1, G2, SUMY, ASTAR, BSTAR, XOUT(2), XGUESS(2)
	REAL * 8  FNORM, XBOUNDS(2, 2), ftol
	INTEGER IMIN, IMAX, NEQ, ierror

	C	FIND THE LIGHTEST AND HEAVIEST COMPONENTS IN A MIXTURE
	CALL FINDLIGHTHEAVY(Z, IMIN, IMAX)
	C	TEST BASED ON LIGHTEST COMPONENT
	ASTAR = AD(IMIN)
	BSTAR = BD(IMIN)
	C	SOLVE 2 EQUATIONS USING NR METHOD - LIGHT COMPONENT
	XBOUNDS = -100.0D0
	XBOUNDS(1, 1:2) = 0.0D0
	NEQ = 2
	XGUESS(1) = ASTAR
	XGUESS(2) = BSTAR
	XOUT = 0.0D0
	PHASEFLAG = .FALSE.
	IERROR = 0
	ftol = 1.0d - 08
	fnorm = 0.0D0
	check = .false.
	C	CALCUATE YI, EVALUATE CHECK FUNCTIONS
	call NRSolve(XGUESS, xout, NEQ, CHECK, FCNSTAB, .FALSE.,
		*JACStab, FNORM, XBOUNDS, ftol, IERROR)
	G1 = ABS(XOUT(1) - THETAT(1))
	G2 = ABS(XOUT(2) - THETAT(5))
	SUMY = SUM(YI)
	IF((SUMY.GE.1.0d0).AND.((G1 + G2).GT.0.0001d0)) THEN
	STABILITYFLAG = .FALSE.
	RETURN
	ENDIF
	C	CHECK HEAVY COMPONENT
	ASTAR = AD(IMAX)
	BSTAR = BD(IMAX)
	C	SOLVE 2 EQUATIONS USING NR METHOD - HEAVY COMPONENT
	NEQ = 2
	XGUESS(1) = ASTAR
	XGUESS(2) = BSTAR
	XOUT = 0.0D0
	PHASEFLAG = .TRUE.
	C	CALCUATE YI, EVALUATE CHECK FUNCTIONS
	IERROR = 0
	fnorm = 0.0d0
	check = .false.
	call NRSolve(XGUESS, xout, NEQ, CHECK, FCNSTAB, .FALSE.,
		*JACStab, FNORM, XBOUNDS, ftol, IERROR)
	G1 = ABS(XOUT(1) - THETAT(1))
	G2 = ABS(XOUT(2) - THETAT(5))
	SUMY = SUM(YI)
	IF((SUMY.GE.1.0d0).AND.((G1 + G2).GT.0.0001d0)) THEN
	STABILITYFLAG = .FALSE.
	RETURN
	ENDIF
	STABILITYFLAG = .TRUE.
	RETURN
	END




	SUBROUTINE FCNSTAB(P, F, N)
	USE RAPIDDATA
	IMPLICIT NONE
	INTEGER N, I
	REAL * 8 P(N), F(N), ZSTAR, YLN
	REAL * 8 ASTAR, BSTAR, FUGSTAR(NC), AMIX
	C
	C	P(1) = ASTAR
	C	P(2) = BSTAR

	C	Calulate Fugacity, FUGSTAR
	AMIX = P(1)*P(1)
	ASTAR = P(1)
	BSTAR = P(2)
	CALL CALCZ(YI, AMIX, BSTAR, U, W, ZSTAR, PHASEFLAG, .FALSE.)
	CALL CALCLOGFUGACITY(AD, BD, ASTAR, BSTAR, U, W, ZSTAR, FUGSTAR)
	C	CALCUATE YI, EVALUATE CHECK FUNCTIONS
	YI = 0.0D0
	F = 0.0D0
	DO I = 1, NC
	IF(Z(I).GT.0.0D0) THEN
	YLN = LOG(Z(I)) + FUGFEED(I) - FUGSTAR(I)
	IF(YLN.GT.35.0D0) YLN = 35.0D0
	IF(YLN.LT. - 35.0D0) YLN = -35.0D0
	YI(I) = EXP(YLN)
	F(1) = F(1) + YI(I)*(AD(I) - ASTAR)
	F(2) = F(2) + YI(I)*(BD(I) - BSTAR)
	ENDIF
	ENDDO
	RETURN
	END


	subroutine JACStab(n, x, fjac)
	c	Analytical Jacobian for Stability calc
	integer n
	real * 8 fjac(n, n), x(n)

	return
	end


	SUBROUTINE LOGFUGACITY(XX, ISLIQUID, FUG)
	USE RAPIDDATA
	IMPLICIT NONE
	LOGICAL ISLIQUID
	REAL * 8  ASTAR, BSTAR
	REAL * 8  XX(NC), ZSTAR, FUG(NC), AMIX
	INTEGER I
	C	INITIALIZE
	ASTAR = 0.0D0
	BSTAR = 0.0D0
	DO I = 1, NC
	IF(Z(I).GT.0.0D0) THEN
	ASTAR = XX(I)*AD(I)
	BSTAR = XX(I)*BD(I)
	ENDIF
	ENDDO
	C	CALCULATE FUGACITY
	AMIX = ASTAR * ASTAR
	CALL CALCZ(XX, AMIX, BSTAR, U, W, ZSTAR, ISLIQUID, .FALSE.)
	CALL CALCLOGFUGACITY(AD, BD, ASTAR, BSTAR, U, W, ZSTAR, FUG)
	RETURN
	END


	SUBROUTINE SOLVEDIRECTSUB(MAXCOUNT, FNORM, FTOL, IERROR)
	C	THIS SUBROUTINE DOES A SEQUENTIAL SUBSTITUTION SOLUTION
	C	TO THE FLASH CALCULATION
	C		INTEGER		MAXCOUNT	MAXIMUM NO.OF ITERATIONS
	C		REAL * 8		FNORM		THE TOTAL ABS ERROR IN KVAP
	C		REAL * 8		FTOL		THE STOPPING TOLERANCE, COMPARE FNORM
	C		REAL * 8		IERROR		ERROR FLAG : 0 = NO ERROR
	C
	USE RAPIDDATA
	IMPLICIT NONE
	INTEGER N, I, K, MAXCOUNT, J, IERROR
	REAL * 8 VAPKOLD(NC), GR, GROLD, P(3), F(3), FNORM, FTOL

	N = 3
	K = 0
	J = 0
	P(1) = THETAL(1)
	P(2) = THETAL(5)
	P(3) = THETAL(6)
	F = 0.0D0
	FNORM = 0.0D0
	VAPFRAC = 1.0D0 - P(3)
	THETAV(1) = (THETAT(1) - THETAL(1)*(1.0D0 - VAPFRAC)) / VAPFRAC
	THETAV(5) = (THETAT(5) - THETAL(5)*(1.0D0 - VAPFRAC)) / VAPFRAC
	THETAV(6) = VAPFRAC
	CALL FCNRF(P, F, N)
	CALL REDUCEDGIBBS(X, Y, Z, FUGACITYL, FUGACITYV, FUGFEED, VAPFRAC, GROLD)
	IERROR = 0
	FNORM = 100.
	DO WHILE((FNORM.GT.FTOL).AND.(IERROR.EQ.0))
	K = K + 1
	C		CALCULATE NEXT VAPFRAC, AV, BV
	CALL UPDATETHETA
	C		CHECK FOR GIBBS ENERGY REDUCTION, CALCULATE TANGENT
	C		PLANE DISTANCES
	CALL REDUCEDGIBBS(X, Y, Z, FUGACITYL, FUGACITYV, FUGFEED,
		*VAPFRAC, GR)
	IF(GR.GT.GROLD)THEN
	C			NOT CONVERGING ?
	J = J + 1
	ELSE
	J = 0
	ENDIF
	C		CALCULATE FUGACITIES AND THEN NEW VAPK
	CALL KVAPCALC
	C		CALCULATE CHANGE IN KVAP
	FNORM = 0.0D0
	DO I = 1, NC
	FNORM = FNORM + ABS(VAPKOLD(I) - VAPK(I))
	ENDDO
	VAPKOLD = VAPK
	GROLD = GR
	IF(K.GT.MAXCOUNT) IERROR = K
	IF(J.GT.3) IERROR = -1
	ENDDO
	RETURN
	END


	SUBROUTINE REDUCEDGIBBS(X, Y, Z, FUGX, FUGY, FUGZ, BETA, GR)
	C	CALC THE REDUCED GIBBS ENERGY BY TANGENT PLANE DISTANCE
	C	M.L.MICHELSEN, COMPUTERS CHEM ENGR VOL 17, NO5 / 6, P431
	USE RAPIDDATA, ONLY: NC
	IMPLICIT NONE
	INTEGER I
	REAL * 8  X(NC), Y(NC), Z(NC), FUGX(NC), FUGY(NC), FUGZ(NC), BETA
	REAL * 8  TPDX, TPDY, GR

	TPDX = 0.0
	TPDY = 0.0
	DO I = 1, NC
	IF(Z(I).GT.0.0D0) THEN
	TPDX = TPDX + X(I)*(DLOG(X(I)) + FUGX(I) -
		&DLOG(Z(I)) - FUGZ(I))
	TPDY = TPDY + Y(I)*(DLOG(Y(I)) + FUGY(I) -
		&DLOG(Z(I)) - FUGZ(I))
	ENDIF
	ENDDO
	GR = BETA * TPDY + (1.0D0 - BETA)*TPDX
	RETURN
	END




	SUBROUTINE WILSONAPPROX(VAPK, PATM, TK, Z)
	C	INITIALIZE VAPK ARRAY USING WILSON APPROXIMATION
	USE COMPDATA
	IMPLICIT NONE
	REAL * 8	VAPK(KL), PATM, TK, PINV, TINV, Z(KL), LNK
	INTEGER I

	PINV = 1.0D0 / PATM
	TINV = 1.0D0 / TK
	DO I = 1, KL
	IF(Z(I).GT.0.0D0) THEN
	C				SEE POKKI THESIS, WILSON APPROX.
	C				EMPIRICAL ADDITION OF PRESSURE SQUARED TERM TO IMPROVE
	C				INITIAL GUESS FOR HIGH PRESSURE SYSTEMS
	LNK = LOG(PC(I)*PINV) + 5.373D0*(ACEN(I) + 1.0D0)*
	*										(1.0D0 - (TINV*TC(I)))
	VAPK(I) = DEXP(LNK)
	ENDIF
	ENDDO
	RETURN
	END

	SUBROUTINE ZEROVARIABLES
	C	THIS SUBROUTINE ZEROS THE COMMON VARIABLES
	USE RAPIDDATA
	THETAV = 0.0D0
	THETAL = 0.0D0
	THETAT = 0.0D0
	Y = 0.0D0
	X = 0.0D0
	Z = 0.0D0
	AD = 0.0D0
	BD = 0.0D0
	VAPK = 0.0D0
	ZL = 0.0D0
	ZV = 0.0D0
	VAPFRAC = 0.0
	ANEW = 0.0D0
	B = 0.0D0
	FUGACITYL = 0.0D0
	FUGACITYV = 0.0D0
	FUGFEED = 0.0D0
	S = 0.0D0
	YI = 0.0D0
	H = 0.0D0
	G = 0.0D0
	PDB = 0.0D0
	PDAX = 0.0D0
	PDZ = 0.0D0
	PDA = 0.0D0
	RETURN
	END



	SUBROUTINE FCNrf(P, F, N)
	USE RAPIDDATA
	IMPLICIT NONE
	INTEGER N, I
	REAL * 8 P(N), F(N), TOTX, TOTY
	C
	C	P(1) = THETAL(1) AKA SUM(Xi*ANEWi) OR AL
	C	P(2) = THETAL(5) AKA SUM(Xi*Bi) OR BL
	C	P(3) = THETAL(6) AKA 1.0 - VAPOR FRACTION

	C	UPDATE THETA ARRAYS
	THETAL(1) = P(1)
	THETAL(5) = P(2)
	THETAL(6) = P(3)
	VAPFRAC = 1.0D0 - THETAL(6)
	THETAV(1) = (THETAT(1) - THETAL(1)*(1.0D0 - VAPFRAC)) / VAPFRAC
	THETAV(5) = (THETAT(5) - THETAL(5)*(1.0D0 - VAPFRAC)) / VAPFRAC
	THETAV(6) = VAPFRAC
	C	CALCULATE VAPK
	TOTX = SUM(X)
	TOTY = SUM(Y)
	CALL KVAPCALC
	x = 0.0d0
	y = 0.0d0
	C	UPDATE X AND Y, NORMALIZE
	DO I = 1, NC
	if (z(i).gt.0.0d0) then
		X(I) = Z(I) / (1.0D0 + VAPFRAC * (VAPK(I) - 1.0D0))
		Y(I) = VAPK(I)*X(I)
		endif
		ENDDO
		TOTX = SUM(X)
		TOTY = SUM(Y)
		IF(TOTX.NE.0.0D0)THEN
		X = X / TOTX
		ELSE
		X = 0.0D0
		ENDIF
		IF(TOTY.NE.0.0D0)THEN
		Y = Y / TOTY
		ELSE
		Y = 0.0D0
		ENDIF
		C	EVALUATE THE THREE EQUATIONS
		F = 0.0D0
		DO I = 1, NC
		if (z(i).gt.0.0d0) then
			F(1) = F(1) + (X(I)*AD(I))
			F(2) = F(2) + (X(I)*BD(I))
			F(3) = F(3) + (Z(I)*(1.0D0 - VAPK(I))) /
			&(VAPK(I) + P(3)*(1.0D0 - VAPK(I)))
			endif
			ENDDO
			F(1) = P(1) - F(1)
			F(2) = P(2) - F(2)
			RETURN
			END



			SUBROUTINE LSJACrf(N, XVAL, FJAC)
			C	CALCULATE THE JACOBIAN FOR THE NEWTON - RAPHSON SOLUTION
			C	OF THE FLASH CALCULATION.DUMMY SUB
			USE RAPIDDATA
			IMPLICIT NONE
			INTEGER N
			REAL * 8 XVAL(N), FJAC(N, N)
			RETURN
			END


			SUBROUTINE UPDATETHETA
			C	THIS SUB UPDATES THE THETA ARRAYS BASED ON X AND Y ARRAYS
			C	SOLVE FOR VAPFRAC USING RACHFORD - RICE METHOD
			USE RAPIDDATA
			IMPLICIT NONE
			INTEGER I, IERROR
			REAL * 8 TOTX, TOTY

			CALL RACHFORDRICE2(VAPK, Z, VAPFRAC, IERROR)
			C	CHECK RESULTS OF VAPFRAC
			IF(VAPFRAC.LE.0.0D0) THEN
			C		CALCULATE NEW X AND Y
			DO I = 1, NC
			IF(Z(I).GT.0.0D0) THEN
			X(I) = Z(I)
			Y(I) = Z(I)*VAPK(I)
			ENDIF
			ENDDO
			ELSEIF(VAPFRAC.GE.1.0D0) THEN
			C		CALCULATE NEW X AND Y
			DO I = 1, NC
			IF(Z(I).GT.0.0D0) THEN
			X(I) = Z(I) / VAPK(I)
			Y(I) = Z(I)
			ENDIF
			ENDDO
			ELSE
			C		CALCULATE NEW X AND Y
			DO I = 1, NC
			IF(Z(I).GT.0.0D0) THEN
			X(I) = Z(I) / (1.0D0 + VAPFRAC * (VAPK(I) - 1.0D0))
			Y(I) = VAPK(I)*X(I)
			ENDIF
			ENDDO
			ENDIF
			TOTX = SUM(X)
			TOTY = SUM(Y)
			IF(TOTX.GT.0.0D0) THEN
			X = X / TOTX
			ENDIF
			IF(TOTY.GT.0.0D0) THEN
			Y = Y / TOTY
			ENDIF
			C	RECALCULATE THETA ARRAYS
			THETAL = 0.0
			THETAV = 0.0
			DO I = 1, NC
			THETAL(1) = THETAL(1) + X(I)*AD(I)
			THETAL(5) = THETAL(5) + X(I)*BD(I)
			THETAV(1) = THETAV(1) + Y(I)*AD(I)
			THETAV(5) = THETAV(5) + Y(I)*BD(I)
			ENDDO
			THETAL(6) = 1.0 - VAPFRAC
			THETAV(6) = VAPFRAC

			RETURN
			END


			SUBROUTINE FINDLIGHTHEAVY(Z, IMIN, IMAX)
			C	THIS SUB EXAMINES THE Z ARRAY AND FINDS THE LIGHTEST AND HEAVIEST
			C	COMPONENTS.THE LIGHTEST AND HEAVIEST ARE FOUND BY MW.
			USE COMPDATA
			IMPLICIT NONE
			INTEGER * 4	IMIN, IMAX, I, ISTART
			REAL * 8 Z(KL), TARGETMW

			C	FIND THE LIGHTEST, CHECK IF H2(COMPONENT 1)
			IMIN = 0
			IF(Z(1).GT.0.0D0) THEN
			IMIN = 1
			ELSE
			DO I = 2, KL
			IF(Z(I).GT.0.0D0) THEN
			ISTART = I + 1
			TARGETMW = MW(I)
			IMIN = I
			EXIT
			ENDIF
			ENDDO
			DO I = ISTART, KL
			IF(Z(I).GT.0.0D0) THEN
			IF(MW(I).LT.TARGETMW)THEN
			TARGETMW = MW(I)
			IMIN = I
			ENDIF
			ENDIF
			ENDDO
			ENDIF
			C	FIND THE HEAVIEST
			IMAX = 0
			TARGETMW = 0.0D0
			DO I = 1, KL
			IF(Z(I).GT.0.0D0) THEN
			IF(MW(I).GE.TARGETMW)THEN
			TARGETMW = MW(I)
			IMAX = I
			ENDIF
			ENDIF
			ENDDO
			RETURN
			END


			SUBROUTINE SOLVENEWTONRAPHSON(FTOL, FNORM, CHECKFLAG, IERROR)
			C	SOLVE THE THREE EQUATION FLASH CALCULATION WITH N - R WITH
			C	LINE SEARCH METHOD.
			USE RAPIDDATA
			IMPLICIT NONE
			EXTERNAL FCNRF, LSJACRF
			INTEGER * 4 IERROR, NEQ
			REAL * 8	XOUT(3), XGUESS(3), FNORM, FTOL, XBOUNDS(2, 3)
			LOGICAL CHECKFLAG, USEAJ

			C	SOLVE 3 EQUATIONS USING NEWTON - RAPHSON WITH LINE SEARCH METHOD
			XBOUNDS = -100.0D0
			XBOUNDS(1, 1:3) = 0.0D0
			XBOUNDS(2, 3) = 1.0D0
			NEQ = 3
			XGUESS(1) = THETAL(1)
			XGUESS(2) = THETAL(5)
			XGUESS(3) = THETAL(6)
			XOUT = 0.0D0
			IERROR = 0
			FNORM = 0.0D0
			CHECKFLAG = .FALSE.
			IF(XGUESS(3).LT.0.00001) XGUESS(3) = 0.00001
			IF(XGUESS(3).GT.0.99999) XGUESS(3) = 0.99999
			USEAJ = .FALSE.
			C	SOLVE THE SYSTEM
			CALL NRSOLVE(XGUESS, XOUT, NEQ, CHECKFLAG, FCNRF,
				*USEAJ, LSJACRF, FNORM, XBOUNDS, FTOL, IERROR)
			RETURN
			END
***/